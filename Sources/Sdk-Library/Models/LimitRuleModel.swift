//
// LimitRuleModel.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** ViewModel правила лимита. */
public struct LimitRuleModel: Codable, JSONEncodable, Hashable {

    /** Идентификатор правила. */
    public var id: Int?
    /** Readonly-правило базовой безопасности. */
    public var system: Bool?
    /** Имя правила. */
    public var name: String?
    public var limitType: LimitTypeModel?
    public var period: LimitPeriod?
    public var currency: CurrencyViewModel?
    /** Идентификатор карты. */
    public var cardId: Int?
    public var device: DeviceBaseViewModel?
    public var merchant: MerchantInfoShortWithNullableIdViewModel?
    public var legal: LegalViewModel?
    /** Время блокировки при превышении лимита. */
    public var blockTimeInSeconds: Int?
    public var timeModel: TimeModel?
    /** Значение лимита. */
    public var limitBorders: [LimitBorderModel]?
    /** Номер телефона {Loymax.Limits.Implementation.OtherLimits.Rules.LimitSmsRule.Phone}. */
    public var phone: String?
    /** Идентификатор пользователя {Loymax.Limits.Implementation.OperationsWithCardLimits.Rules.LimitGetCardInfoRule.PersonId}. */
    public var userId: Int?
    /** Заархивировано или нет. */
    public var isArchived: Bool?
    /** Название метода API. */
    public var apiMethodName: String?
    /** Лимит срабатывает при любом запросе. */
    public var isAlwaysExecute: Bool?
    public var identifierArea: IdentifierArea?
    /** Тип подписки. */
    public var subscriptionType: Int?
    public var channelType: MailingWaySendType?

    public init(id: Int? = nil, system: Bool? = nil, name: String? = nil, limitType: LimitTypeModel? = nil, period: LimitPeriod? = nil, currency: CurrencyViewModel? = nil, cardId: Int? = nil, device: DeviceBaseViewModel? = nil, merchant: MerchantInfoShortWithNullableIdViewModel? = nil, legal: LegalViewModel? = nil, blockTimeInSeconds: Int? = nil, timeModel: TimeModel? = nil, limitBorders: [LimitBorderModel]? = nil, phone: String? = nil, userId: Int? = nil, isArchived: Bool? = nil, apiMethodName: String? = nil, isAlwaysExecute: Bool? = nil, identifierArea: IdentifierArea? = nil, subscriptionType: Int? = nil, channelType: MailingWaySendType? = nil) {
        self.id = id
        self.system = system
        self.name = name
        self.limitType = limitType
        self.period = period
        self.currency = currency
        self.cardId = cardId
        self.device = device
        self.merchant = merchant
        self.legal = legal
        self.blockTimeInSeconds = blockTimeInSeconds
        self.timeModel = timeModel
        self.limitBorders = limitBorders
        self.phone = phone
        self.userId = userId
        self.isArchived = isArchived
        self.apiMethodName = apiMethodName
        self.isAlwaysExecute = isAlwaysExecute
        self.identifierArea = identifierArea
        self.subscriptionType = subscriptionType
        self.channelType = channelType
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case system
        case name
        case limitType
        case period
        case currency
        case cardId
        case device
        case merchant
        case legal
        case blockTimeInSeconds
        case timeModel
        case limitBorders
        case phone
        case userId
        case isArchived
        case apiMethodName
        case isAlwaysExecute
        case identifierArea
        case subscriptionType
        case channelType
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(system, forKey: .system)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(limitType, forKey: .limitType)
        try container.encodeIfPresent(period, forKey: .period)
        try container.encodeIfPresent(currency, forKey: .currency)
        try container.encodeIfPresent(cardId, forKey: .cardId)
        try container.encodeIfPresent(device, forKey: .device)
        try container.encodeIfPresent(merchant, forKey: .merchant)
        try container.encodeIfPresent(legal, forKey: .legal)
        try container.encodeIfPresent(blockTimeInSeconds, forKey: .blockTimeInSeconds)
        try container.encodeIfPresent(timeModel, forKey: .timeModel)
        try container.encodeIfPresent(limitBorders, forKey: .limitBorders)
        try container.encodeIfPresent(phone, forKey: .phone)
        try container.encodeIfPresent(userId, forKey: .userId)
        try container.encodeIfPresent(isArchived, forKey: .isArchived)
        try container.encodeIfPresent(apiMethodName, forKey: .apiMethodName)
        try container.encodeIfPresent(isAlwaysExecute, forKey: .isAlwaysExecute)
        try container.encodeIfPresent(identifierArea, forKey: .identifierArea)
        try container.encodeIfPresent(subscriptionType, forKey: .subscriptionType)
        try container.encodeIfPresent(channelType, forKey: .channelType)
    }
}

